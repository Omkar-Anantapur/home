<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Business Case Episodes</title>
<style>
/* SAME STYLE – NO CHANGES */
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #0e0e0e;
    color: #fff;
}
header {
    background: #111;
    padding: 20px;
    text-align: center;
    font-size: 30px;
    font-weight: bold;
    letter-spacing: 1px;
}
.container {
    padding: 20px;
}
.episode-btn {
    background: #222;
    padding: 15px;
    border-radius: 6px;
    margin: 10px 0;
    cursor: pointer;
    font-size: 20px;
    transition: 0.3s;
}
.episode-btn:hover {
    background: #333;
}
.episode-content {
    display: none;
    background: #1a1a1a;
    padding: 20px;
    margin-top: 10px;
    border-left: 4px solid #0af;
}
pre {
    background: #000;
    padding: 15px;
    overflow-x: auto;
    border-radius: 6px;
    border: 1px solid #444;
}
</style>

<script>
// SAME JS – NO CHANGES
function toggle(id) {
    var box = document.getElementById(id);
    box.style.display = (box.style.display === "block") ? "none" : "block";
}
</script>

</head>
<body>

<header>Business Case Episodes (1–10)</header>

<div class="container">

<!-- CASE 1 -->
<div class="episode-btn" onclick="toggle('c1')">⭐ BUSINESS CASE 1 — Smart Billboard Advertisement Allocation Optimizer</div>
<div id="c1" class="episode-content">
<h2>1. What it means</h2>
<p>Optimizes the allocation of digital billboards to advertisers to maximize revenue while ensuring fair exposure time.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Prevents overbooking of popular billboards</li>
<li>Ensures advertisers get fair time share</li>
<li>Maximizes city revenue</li>
<li>Helps schedule thousands of ads daily</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Ad Requests → Sort by Profit/Duration → Greedy Slot Selection → Final Schedule</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int n, T;
    cin >> n >> T;
    vector&lt;pair&lt;double,int&gt;&gt; ads;

    for(int i=0;i&lt;n;i++){
        double p; int t;
        cin >> p >> t;
        ads.push_back({p/t, t});
    }

    sort(ads.rbegin(), ads.rend());

    int used = 0;
    for(auto &a : ads){
        if(used + a.second <= T){
            used += a.second;
        }
    }
    cout << "Used time: " << used;
}
</pre>

<h2>5. Algorithm Used</h2>
<p>Greedy interval scheduling based on profit/time ratio.</p>

<h2>6. How code works</h2>
<p>Sort ads by profitability per second, keep selecting until time runs out.</p>

<h2>7. Input Sources</h2>
<p>Advertising platform logs, billboard availability database.</p>
</div>

<!-- CASE 2 -->
<div class="episode-btn" onclick="toggle('c2')">⭐ BUSINESS CASE 2 — Municipal Document Digitization Load Balancer</div>
<div id="c2" class="episode-content">
<h2>1. What it means</h2>
<p>Distributes scanning workload among servers so no server is overloaded.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Large cities scan millions of documents</li>
<li>Prevents server slowdown</li>
<li>Ensures timely digitization</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Document Sizes → Min-Heap of Servers → Assign to Lightest Loaded</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n,m; cin>>n>>m;
    vector&lt;int&gt; docs(n);
    for(int &x: docs) cin>>x;

    priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;&gt;&gt; pq;
    for(int i=0;i&lt;m;i++) pq.push({0,i});

    for(int x : docs){
        auto [load,id] = pq.top(); pq.pop();
        load += x;
        pq.push({load,id});
    }

    auto res = pq.top();
    cout << "Max load on server: " << res.first;
}
</pre>

<h2>5. Algorithm Used</h2>
<p>Greedy load balancing using min-heap.</p>

<h2>6. How code works</h2>
<p>Always assigns next document to the server with lowest load.</p>

<h2>7. Input Sources</h2>
<p>Document sizes, server performance data.</p>
</div>

<!-- CASE 3 -->
<div class="episode-btn" onclick="toggle('c3')">⭐ BUSINESS CASE 3 — Public Feedback Clustering & Issue Prioritizer</div>
<div id="c3" class="episode-content">

<h2>1. What it means</h2>
<p>Automatically groups similar citizen complaints and ranks the most common issues.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Prevents backlog</li>
<li>Helps the city identify common issues</li>
<li>Automates complaint categorization</li>
</ul>

<h2>3. Decision Flow</h2>
<p>TF-IDF → K-Means → Rank by Cluster Size</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n,k; cin>>n>>k;
    vector&lt;int&gt; cluster(n);
    for(int &x: cluster) cin >> x;

    vector&lt;int&gt; count(k,0);
    for(int x: cluster) count[x]++;

    int best = max_element(count.begin(), count.end()) - count.begin();
    cout << "Top priority cluster: " << best;
}
</pre>

<h2>5. Algorithm Used</h2>
<p>K-means clustering + frequency ranking.</p>

<h2>6. How code works</h2>
<p>Counts how many complaints belong to each cluster, picks biggest.</p>

<h2>7. Input Sources</h2>
<p>Citizen app feedback, social media text mining.</p>
</div>

<!-- CASE 4 -->
<div class="episode-btn" onclick="toggle('c4')">⭐ BUSINESS CASE 4 — Festival Crowd Movement Simulation & Exit Optimization</div>
<div id="c4" class="episode-content">

<h2>1. What it means</h2>
<p>Simulates crowd movement and optimizes emergency exit locations.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Prevents stampedes</li>
<li>Improves emergency planning</li>
<li>Detects bottlenecks</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Grid → BFS → Bottleneck Detection → Exit Optimization</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n; cin>>n;
    vector&lt;string&gt; grid(n);
    for(auto &s:grid) cin>>s;

    queue&lt;pair&lt;int,int&gt;&gt; q;
    vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, -1));

    q.push({0,0});
    dist[0][0]=0;

    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};

    while(!q.empty()){
        auto [x,y]=q.front(); q.pop();
        for(int k=0;k&lt;4;k++){
            int nx=x+dx[k], ny=y+dy[k];
            if(nx>=0 && ny>=0 && nx&lt;n && ny&lt;n && grid[nx][ny]!='#' && dist[nx][ny]==-1){
                dist[nx][ny]=dist[x][y]+1;
                q.push({nx,ny});
            }
        }
    }

    cout << "Max crowd distance: " << dist[n-1][n-1];
}
</pre>

<h2>5. Algorithm Used</h2>
<p>BFS for crowd flow simulation.</p>

<h2>6. How code works</h2>
<p>Computes time for crowd to reach exits → identifies bottlenecks.</p>

<h2>7. Input Sources</h2>
<p>CCTV heatmaps, pedestrian sensors.</p>
</div>

<!-- CASE 5 -->
<div class="episode-btn" onclick="toggle('c5')">⭐ BUSINESS CASE 5 — Drone Battery Swapping Station Optimization</div>
<div id="c5" class="episode-content">

<h2>1. What it means</h2>
<p>Finds optimal drone battery swapping station locations.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Reduces drone downtime</li>
<li>Ensures large coverage</li>
<li>Supports drone delivery operations</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Drone Routes → K-Median → Station Placement</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

double dist(pair&lt;int,int&gt;a,pair&lt;int,int&gt;b){
    return hypot(a.first-b.first, a.second-b.second);
}

int main(){
    int n; cin>>n;
    vector&lt;pair&lt;int,int&gt;&gt; pts(n);
    for(auto &p:pts) cin>>p.first>>p.second;

    pair&lt;int,int&gt; center = pts[rand()%n];

    double total=0;
    for(auto &p:pts) total+=dist(center,p);

    cout<<"Cost: "<<total;
}
</pre>

<h2>5. Algorithm Used</h2>
<p>K-median (approximation)</p>

<h2>6. How code works</h2>
<p>Selects a center, computes distance cost.</p>

<h2>7. Input Sources</h2>
<p>Drone route data.</p>
</div>

<!-- CASE 6 -->
<div class="episode-btn" onclick="toggle('c6')">⭐ BUSINESS CASE 6 — Smart Emergency Broadcast Channel Optimization</div>
<div id="c6" class="episode-content">

<h2>1. What it means</h2>
<p>Selects minimal channels to cover maximum population.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Ensures alerts reach maximum people</li>
<li>Reduces communication delays</li>
<li>Prevents network overload</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Coverage Data → Greedy Selection → Sufficient Coverage?</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int n; cin >> n;
    vector&lt;int&gt; reach(n);
    for(int &x : reach) cin >> x;

    int target; cin >> target;
    priority_queue&lt;pair&lt;int,int&gt;&gt; pq;

    for(int i=0;i&lt;n;i++) pq.push({reach[i], i});

    int covered=0;
    while(!pq.empty() && covered &lt; target){
        auto [r,id] = pq.top(); pq.pop();
        covered += r;
        cout << "Channel " << id << "\n";
    }
}
</pre>

<h2>5. Algorithm Used</h2>
<p>Greedy set-cover style picking.</p>

<h2>6. How code works</h2>
<p>Selects channel covering maximum people first.</p>

<h2>7. Input Sources</h2>
<p>Telecom coverage, app usage.</p>
</div>

<!-- CASE 7 -->
<div class="episode-btn" onclick="toggle('c7')">⭐ BUSINESS CASE 7 — City Library Dynamic Book Rebalancing System</div>
<div id="c7" class="episode-content">

<h2>1. What it means</h2>
<p>Balances book inventory across libraries based on demand.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Prevents popular book shortages</li>
<li>Reduces movement cost</li>
<li>Improves citizen satisfaction</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Demand → Min-cost Flow → Rebalancing</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n; cin>>n;
    vector&lt;int&gt; need(n), have(n);

    for(int &x: need) cin>>x;
    for(int &x: have) cin>>x;

    sort(need.begin(), need.end());
    sort(have.begin(), have.end());

    int moves=0;
    for(int i=0;i&lt;n;i++)
        moves += abs(need[i] - have[i]);

    cout << "Books to move: " << moves;
}
</pre>

<h2>5. Algorithm Used</h2>
<p>Greedy matching (sorted arrays)</p>

<h2>6. How code works</h2>
<p>Matches supply to demand with minimal moves.</p>

<h2>7. Input Sources</h2>
<p>Library request data.</p>
</div>

<!-- CASE 8 -->
<div class="episode-btn" onclick="toggle('c8')">⭐ BUSINESS CASE 8 — Smart Disaster Inventory Positioning</div>
<div id="c8" class="episode-content">

<h2>1. What it means</h2>
<p>Places emergency kits to minimize worst-case response time.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Saves lives</li>
<li>Reduces travel time</li>
<li>Ensures fair coverage</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Binary Search → Coverage Feasibility</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

bool feasible(int r, vector&lt;int&gt;& pts){
    for(int x : pts) if(x > r) return false;
    return true;
}

int main(){
    int n; cin>>n;
    vector&lt;int&gt; pts(n);
    for(int &x:pts) cin>>x;

    int l=1, r=100000, ans=-1;
    while(l<=r){
        int mid=(l+r)/2;
        if(feasible(mid, pts)) ans=mid, r=mid-1;
        else l=mid+1;
    }

    cout<<"Min radius: "<<ans;
}
</pre>

<h2>5. Algorithm Used</h2>
<p>Binary search for minimax radius.</p>

<h2>6. How code works</h2>
<p>Checks if all points can be covered within radius r.</p>

<h2>7. Input Sources</h2>
<p>Risk maps, warehouse locations.</p>
</div>

<!-- CASE 9 -->
<div class="episode-btn" onclick="toggle('c9')">⭐ BUSINESS CASE 9 — Smart Heatwave Shelter Capacity Planner</div>
<div id="c9" class="episode-content">

<h2>1. What it means</h2>
<p>Ensures shelters can safely host predicted population during heatwaves.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Prevents overcrowding</li>
<li>Saves lives</li>
<li>Improves allocation</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Sort → Binary Search → Feasibility Assignment</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

bool canAssign(vector&lt;int&gt;& pop, vector&lt;int&gt;& cap, int limit){
    int i=0,j=0;
    while(i&lt;pop.size() && j&lt;cap.size()){
        if(pop[i] <= limit && cap[j] >= pop[i]) i++, j++;
        else j++;
    }
    return i==pop.size();
}

int main(){
    int n,m; cin>>n>>m;
    vector&lt;int&gt; pop(n), cap(m);

    for(int &x: pop) cin>>x;
    for(int &x: cap) cin>>x;

    sort(pop.begin(), pop.end());
    sort(cap.begin(), cap.end());

    int l=1,r=100000,ans=-1;
    while(l<=r){
        int mid=(l+r)/2;
        if(canAssign(pop,cap,mid)) ans=mid, r=mid-1;
        else l=mid+1;
    }
    cout<<"Max people per shelter: "<<ans;
}
</pre>

<h2>5. Algorithm Used</h2>
<p>Binary search + greedy matching.</p>

<h2>6. How code works</h2>
<p>Finds smallest max-capacity limit for safe assignment.</p>

<h2>7. Input Sources</h2>
<p>IMD forecast, shelter database.</p>
</div>

<!-- CASE 10 -->
<div class="episode-btn" onclick="toggle('c10')">⭐ BUSINESS CASE 10 — Job Fair Candidate–Company Matching System</div>
<div id="c10" class="episode-content">

<h2>1. What it means</h2>
<p>Matches candidates with companies efficiently.</p>

<h2>2. Why it is necessary</h2>
<ul>
<li>Ensures fair opportunities</li>
<li>Reduces queue time</li>
<li>Improves company satisfaction</li>
</ul>

<h2>3. Decision Flow</h2>
<p>Preferences → Stable Matching → Final Assignment</p>

<h2>4. C++ Code</h2>
<pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n; cin>>n;
    vector&lt;int&gt; pref(n);
    for(int &x: pref) cin>>x;

    sort(pref.begin(), pref.end());
    cout << "First assigned: " << pref[0];
}
</pre>

<h2>5. Algorithm Used</h2>
<p>Stable matching (simplified)</p>

<h2>6. How code works</h2>
<p>Sorts candidates and assigns highest priority first.</p>

<h2>7. Input Sources</h2>
<p>Candidate profiles, company requirements.</p>
</div>

</div>
</body>
</html>
