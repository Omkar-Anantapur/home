<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Business Case Study 1 – Smart Traffic Routing</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  background:#0f172a;
  color:#e5e7eb;
  font-family: "Segoe UI", sans-serif;
  margin:0;
  padding:2rem;
  line-height:1.7;
}
a { color:#38bdf8; text-decoration:none; }
a:hover { text-decoration:underline; }
.container {
  max-width:1100px; margin:auto;
  background:#020617;
  padding:2rem;
  border-radius:12px;
  border:1px solid #1e293b;
}
h1 { color:#e50914; text-align:center; margin-bottom:1.5rem; letter-spacing:2px; }
h2 { margin-top:2rem; color:#f97316; }
h3 { margin-top:1.2rem; color:#a5b4fc; font-weight:600; }
.section {
  margin-top:2rem;
  padding:1.5rem;
  background:#0b1120;
  border-radius:10px;
  border:1px solid #1e293b;
}
pre {
  background:#111827;
  padding:1rem;
  border-radius:8px;
  overflow-x:auto;
  border:1px solid #1e293b;
  font-size:0.9rem;
}
</style>
</head>

<body>

<a href="bheemangouda.html">← Back</a>

<div class="container">

<h1>Business Case Study 1 – Smart Traffic Routing</h1>

<div class="section">
<h2>1. Problem Statement</h2>

<p>
Cities face traffic congestion issues because different routes have different distances, travel times and traffic density. 
The objective is to compute the fastest route between any two junctions using a reliable shortest-path algorithm.
</p>

<p>
We model the city as a graph:
</p>

<ul>
<li>Nodes represent junctions.</li>
<li>Edges represent roads with weights representing time/distance.</li>
<li>The goal is to compute the minimum travel time from a given source junction.</li>
</ul>

</div>

<div class="section">
<h2>2. Algorithm Used: Dijkstra</h2>

<p>
Dijkstra is chosen because:
</p>

<ul>
<li>All edge weights (road distances) are non-negative.</li>
<li>Efficient for large cities.</li>
<li>Works with real-time updates using priority queue.</li>
</ul>

</div>

<div class="section">
<h2>3. Time Complexity Explanation</h2>

<p>
Let V be the number of junctions and E be the number of roads.
</p>

<p>
Using a priority queue:
</p>

<pre>
Time Complexity = (V + E) log V
</pre>

<p>
This works efficiently even when the road network grows large. Therefore, this method suits real-time smart city routing systems.
</p>

</div>

<div class="section">
<h2>4. C++ Code (Clean, runnable, long, structured)</h2>

<p>
The following C++ program demonstrates complete city graph creation and shortest path computation using Dijkstra.
</p>

<pre><code>
#include <bits/stdc++.h>
using namespace std;

struct Road {
    int to;
    int weight;
};

class CityGraph {
public:
    int n;
    vector<vector<Road>> adj;

    CityGraph(int nodes) {
        n = nodes;
        adj.resize(n);
    }

    void addTwoWayRoad(int u, int v, int w) {
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    void printGraph() {
        cout << "Graph Structure:\n";
        for (int i = 0; i < n; i++) {
            cout << "Node " << i << ": ";
            for (auto &r : adj[i]) {
                cout << "(" << r.to << "," << r.weight << ") ";
            }
            cout << "\n";
        }
    }
};

vector<int> dijkstra(CityGraph &G, int src) {
    const int INF = 1e9;
    vector<int> dist(G.n, INF);
    dist[src] = 0;

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (d != dist[u]) continue;

        for (auto &road : G.adj[u]) {
            int v = road.to;
            int w = road.weight;

            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }

    return dist;
}

void printDistances(const vector<int> &dist) {
    cout << "Shortest distances from source:\n";
    for (int i = 0; i < dist.size(); i++) {
        cout << "Node " << i << " -> " << dist[i] << "\n";
    }
}

int main() {
    CityGraph city(6);

    city.addTwoWayRoad(0, 1, 4);
    city.addTwoWayRoad(0, 2, 6);
    city.addTwoWayRoad(1, 2, 1);
    city.addTwoWayRoad(1, 3, 7);
    city.addTwoWayRoad(2, 4, 2);
    city.addTwoWayRoad(3, 5, 3);
    city.addTwoWayRoad(4, 5, 5);

    cout << "City Traffic Graph:\n";
    city.printGraph();

    cout << "\nRunning Dijkstra from Node 0...\n";
    vector<int> dist = dijkstra(city, 0);

    printDistances(dist);

    cout << "\nFinished.\n";
    return 0;
}
</code></pre>

</div>

<div class="section">
<h2>5. Conclusion</h2>

<p>
Dijkstra provides an efficient approach for live traffic routing and smart city systems. 
It ensures optimal travel path discovery with guaranteed accuracy and performance.
</p>

</div>

</div>

</body>
</html>
