<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Abhilash – Case Studies</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
    margin:0;
    font-family:"Segoe UI",sans-serif;
    background:#020617;
    color:#e5e7eb;
}
h1{text-align:center;margin-top:30px;color:#e50914}
.case-buttons{
    max-width:900px;
    margin:30px auto;
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
    gap:20px;
}
.case-btn{
    padding:20px;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.25);
    border-radius:14px;
    text-align:center;
    cursor:pointer;
    transition:.3s;
}
.case-btn:hover{
    transform:translateY(-4px);
    border-color:#e50914;
    box-shadow:0 0 20px rgba(229,9,20,0.4);
}
.case-content{
    display:none;
    max-width:900px;
    margin:40px auto;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.2);
    padding:20px;
    border-radius:14px;
}
pre{
    background:black;
    padding:15px;
    border-radius:12px;
    overflow-x:auto;
    white-space:pre-wrap;
}
</style>

<script>
function openCase(n){
    document.querySelectorAll(".case-content").forEach(c=>c.style.display="none");
    document.getElementById("c"+n).style.display="block";
    window.scrollTo(0,0);
}
</script>
</head>

<body>

<h1>Abhilash – Case Studies (1–10)</h1>

<div class="case-buttons">
<script>
for(let i=1;i<=10;i++){
    document.write(`<div class='case-btn' onclick='openCase(${i})'>Business Case Study ${i}</div>`);
}
</script>
</div>

<!-- ========================================================= -->
<!-- ================= CASE 1 ================================ -->
<!-- ========================================================= -->

<div id="c1" class="case-content">
<h2>1) Dynamic EV Charging Station Placement</h2>

<p><b>Problem Statement:</b>  
Cities need to install EV charging stations so that drivers travel minimum distance and electrical load across substations stays balanced.</p>

<p><b>Algorithm Used:</b> K-Means Clustering + Greedy Load Balancing</p>

<p><b>Time Complexity:</b>  
K-Means: O(I × n × k)</p>

<p><b>Conclusion:</b>  
Provides optimal cluster-based station placement and avoids overload using a secondary greedy assignment.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

using P = pair<double,double>;
double dist(const P&a,const P&b){
    return hypot(a.first-b.first,a.second-b.second);
}

int main(){
    int n=1200, k=25, it=50;
    vector<P> points(n);

    mt19937 rng(1);
    uniform_real_distribution<double> U(0,200);
    for(int i=0;i<n;i++) points[i]={U(rng),U(rng)};

    vector<P> cent(k);
    for(int i=0;i<k;i++) cent[i]=points[i*(n/k)];

    vector<int> assign(n);

    for(int t=0;t<it;t++){
        vector<int> cnt(k,0);
        vector<P> sum(k,{0,0});

        for(int i=0;i<n;i++){
            int best=0; double bestd=1e18;
            for(int j=0;j<k;j++){
                double d=dist(points[i],cent[j]);
                if(d<bestd){bestd=d;best=j;}
            }
            assign[i]=best;
            cnt[best]++;
            sum[best].first+=points[i].first;
            sum[best].second+=points[i].second;
        }
        for(int j=0;j<k;j++){
            if(cnt[j]) cent[j]={sum[j].first/cnt[j],sum[j].second/cnt[j]};
        }
    }

    vector<int> cap(k,150);
    vector<vector<int>> served(k);

    for(int i=0;i<n;i++){
        int s=assign[i];
        if(served[s].size()<cap[s]) served[s].push_back(i);
        else{
            int best=-1; double bd=1e18;
            for(int j=0;j<k;j++){
                if(served[j].size()<cap[j]){
                    double d=dist(points[i],cent[j]);
                    if(d<bd){bd=d;best=j;}
                }
            }
            if(best!=-1) served[best].push_back(i);
        }
    }

    cout<<"Centers:\n";
    for(auto &c:cent) cout<<c.first<<" "<<c.second<<"\n";
}
</pre>
</div>


<!-- ========================================================= -->
<!-- ================= CASE 2 ================================ -->
<!-- ========================================================= -->

<div id="c2" class="case-content">
<h2>2) Public Health Outbreak Detection</h2>

<p><b>Problem Statement:</b>  
Detect disease outbreak clusters using clinic visit data, temporal windows, and geospatial grouping.</p>

<p><b>Algorithm Used:</b> DBSCAN (Spatial) + Temporal Window Filtering</p>

<p><b>Time Complexity:</b> O(n log n)</p>

<p><b>Conclusion:</b>  
This method automatically detects emerging hotspots without supervision.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct P{double x,y; int t;};
double dist(const P&a,const P&b){
    return hypot(a.x-b.x,a.y-b.y);
}

int main(){
    vector<P> pts;
    for(int i=0;i<600;i++)
        pts.push_back({rand()%150, rand()%150, rand()%48});

    int n=pts.size();
    double eps=1.2;
    int minpts=5;

    vector<int> vis(n,0), cid(n,-1);
    int C=0;

    for(int i=0;i<n;i++){
        if(vis[i]) continue;
        vis[i]=1;

        vector<int> nbr;
        for(int j=0;j<n;j++)
            if(dist(pts[i],pts[j])<=eps && abs(pts[i].t-pts[j].t)<=6)
                nbr.push_back(j);

        if(nbr.size()<minpts){cid[i]=-2; continue;}
        cid[i]=C;

        queue<int>q;
        for(int x:nbr) q.push(x);

        while(!q.empty()){
            int u=q.front(); q.pop();
            if(!vis[u]){
                vis[u]=1;
                vector<int> nbr2;
                for(int j=0;j<n;j++)
                    if(dist(pts[u],pts[j])<=eps && abs(pts[u].t-pts[j].t)<=6)
                        nbr2.push_back(j);
                if(nbr2.size()>=minpts)
                    for(int x:nbr2) if(!vis[x]) q.push(x);
            }
            if(cid[u]==-1) cid[u]=C;
        }
        C++;
    }

    cout<<"Clusters: "<<C<<"\n";
}
</pre>
</div>


<!-- ========================================================= -->
<!-- ================= CASE 3 ================================ -->
<!-- ========================================================= -->

<div id="c3" class="case-content">
<h2>3) On-Demand Microtransit Routing</h2>

<p><b>Problem Statement:</b>  
Allocate dynamic requests to minibuses so wait time remains minimal.</p>

<p><b>Algorithm Used:</b> Greedy VRP Insertion</p>

<p><b>Time Complexity:</b> O(m × L)</p>

<p><b>Conclusion:</b>  
A simple but effective real-time heuristic for medium-scale transit systems.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Req{int id; double x,y; int pax;};
struct Bus{int id; double x,y; int cap,load; vector<int> route;};

double dist(pair<double,double>a,pair<double,double>b){
    return hypot(a.first-b.first,a.second-b.second);
}

int main(){
    vector<Bus> bus;
    for(int i=0;i<10;i++)
        bus.push_back({i,rand()%120,rand()%120,15,0,{}});

    auto handle=[&](Req r){
        double best=1e18; int vid=-1;
        for(int i=0;i<bus.size();i++){
            if(bus[i].load+r.pax > bus[i].cap) continue;
            double d = dist({bus[i].x,bus[i].y},{r.x,r.y});
            if(d<best){best=d;vid=i;}
        }
        if(vid==-1){cout<<"Rejected\n";return;}
        bus[vid].route.push_back(r.id);
        bus[vid].load+=r.pax;
        cout<<"Assigned "<<r.id<<" to "<<vid<<"\n";
    };

    for(int i=0;i<50;i++)
        handle({i,rand()%120,rand()%120,1});

    return 0;
}
</pre>
</div>
        <!-- ========================================================= -->
<!-- ================= CASE 4 ================================ -->
<!-- ========================================================= -->

<div id="c4" class="case-content">
<h2>4) Waste Collection Route Optimization</h2>

<p><b>Problem Statement:</b>  
City garbage trucks must collect waste from bins whose fill-level changes daily.  
Goal is to reduce fuel & time by merging nearby stops and forming efficient routes.</p>

<p><b>Algorithm Used:</b> Clarke–Wright Savings Heuristic</p>

<p><b>Time Complexity:</b> O(n²)</p>

<p><b>Conclusion:</b>  
A classical VRP heuristic that merges routes based on maximum “savings” and reduces total travel distance.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Node{
    int id;
    double x,y;
    int demand;
};

double dist(Node&a, Node&b){
    return hypot(a.x-b.x, a.y-b.y);
}

int main(){
    Node depot={0,50,50,0};
    int n=25;

    vector<Node> nodes;
    for(int i=1;i<=n;i++)
        nodes.push_back({i, rand()%100, rand()%100, rand()%25+10});

    int capacity=250;

    struct Route{ vector<int> seq; int load; };
    map<int,Route> routes;

    for(auto &nd:nodes)
        routes[nd.id]={{nd.id}, nd.demand};

    vector<tuple<double,int,int>> savings;

    for(int i=0;i<n;i++){
        for(int j=i+1;j<n;j++){
            double s = dist(depot,nodes[i]) + dist(depot,nodes[j]) - dist(nodes[i],nodes[j]);
            savings.push_back({s,nodes[i].id,nodes[j].id});
        }
    }

    sort(savings.begin(), savings.end(), greater<>());

    for(auto &sv : savings){
        double s; int a,b;
        tie(s,a,b)=sv;

        int ra=-1, rb=-1;

        for(auto &r:routes){
            auto &seq=r.second.seq;
            if(seq.front()==a || seq.back()==a) ra=r.first;
            if(seq.front()==b || seq.back()==b) rb=r.first;
        }

        if(ra<0 || rb<0 || ra==rb) continue;

        if(routes[ra].load + routes[rb].load <= capacity){
            vector<int> merged = routes[ra].seq;
            merged.insert(merged.end(), routes[rb].seq.begin(), routes[rb].seq.end());
            routes[ra].seq = merged;
            routes[ra].load += routes[rb].load;
            routes.erase(rb);
        }
    }

    cout<<"Final routes: "<<routes.size()<<"\n";
}
</pre>
</div>



<!-- ========================================================= -->
<!-- ================= CASE 5 ================================ -->
<!-- ========================================================= -->

<div id="c5" class="case-content">
<h2>5) Smart Streetlight Energy Optimization</h2>

<p><b>Problem Statement:</b>  
City wants to choose which streetlights stay ON during low-traffic hours to ensure safety while saving energy.</p>

<p><b>Algorithm Used:</b> Greedy Selection by (Safety Benefit / Energy Cost)</p>

<p><b>Time Complexity:</b> O(n log n)</p>

<p><b>Conclusion:</b>  
Maximizes safety coverage within fixed energy budget using simple greedy ratio sorting.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Slot{
    int id;
    int energy;
    double safety;
};

int main(){
    int n=150;
    int budget=1600;

    vector<Slot> lamps;
    for(int i=0;i<n;i++)
        lamps.push_back({i, rand()%25+8, (rand()%100)/100.0});

    sort(lamps.begin(), lamps.end(),
         [](auto&a, auto&b){
             return (a.safety/a.energy) > (b.safety/b.energy);
         });

    int used=0;
    vector<int> on;

    for(auto &s: lamps){
        if(used + s.energy <= budget){
            used += s.energy;
            on.push_back(s.id);
        }
    }

    cout<<"Lights ON: "<<on.size()<<"\n";
}
</pre>
</div>



<!-- ========================================================= -->
<!-- ================= CASE 6 ================================ -->
<!-- ========================================================= -->

<div id="c6" class="case-content">
<h2>6) Micro-Fulfillment Center Placement</h2>

<p><b>Problem Statement:</b>  
E-commerce companies need local fulfillment centers to minimize delivery time.</p>

<p><b>Algorithm Used:</b> Greedy Facility Location (k-Median Approximation)</p>

<p><b>Time Complexity:</b> O(n × k)</p>

<p><b>Conclusion:</b>  
Greedy approach gives near-optimal locations for warehouses by opening centers with best improvement.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

using P = pair<double,double>;

double dist(const P&a,const P&b){
    return hypot(a.first-b.first,a.second-b.second);
}

int main(){
    int n=500, cand=60, K=10;

    vector<P> D(n), C(cand);

    for(int i=0;i<n;i++) D[i]={rand()%200, rand()%200};
    for(int i=0;i<cand;i++) C[i]={rand()%200, rand()%200};

    vector<int> open;
    vector<int> assign(n, -1);

    for(int step=0; step<K; step++){
        double bestGain=-1;
        int bestC=-1;

        for(int c=0;c<cand;c++){
            if(find(open.begin(),open.end(),c)!=open.end()) continue;

            double gain=0;

            for(int i=0;i<n;i++){
                double curDist = (assign[i]==-1 ? 1e9 : dist(D[i], C[assign[i]]));
                double newDist = dist(D[i], C[c]);
                if(newDist < curDist)
                    gain += (curDist - newDist);
            }
            if(gain > bestGain){
                bestGain = gain;
                bestC = c;
            }
        }

        if(bestC == -1) break;

        open.push_back(bestC);

        for(int i=0;i<n;i++){
            double bestd = 1e18;
            int idx=-1;
            for(int o : open){
                double d = dist(D[i], C[o]);
                if(d < bestd){ bestd=d; idx=o; }
            }
            assign[i] = idx;
        }
    }

    cout<<"Opened centers: "<<open.size()<<"\n";
}
</pre>
</div>



<!-- ========================================================= -->
<!-- ================= CASE 7 ================================ -->
<!-- ========================================================= -->

<div id="c7" class="case-content">
<h2>7) Adaptive Bicycle Lane Reallocation</h2>

<p><b>Problem Statement:</b>  
During peak cycling hours, the city reallocates car lanes to bike lanes to reduce congestion and accidents.</p>

<p><b>Algorithm Used:</b> Dinic’s Max Flow Algorithm</p>

<p><b>Time Complexity:</b> O(E × √V)</p>

<p><b>Conclusion:</b>  
Computes the maximum safe bike capacity on a road network after lane reallocation.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Edge{int to,rev,cap;};

struct Dinic{
    int N;
    vector<vector<Edge>> G;
    vector<int> level, it;

    Dinic(int n):N(n),G(n),level(n),it(n){}

    void addEdge(int u,int v,int c){
        G[u].push_back({v,(int)G[v].size(),c});
        G[v].push_back({u,(int)G[u].size()-1,0});
    }

    bool bfs(int s,int t){
        fill(level.begin(), level.end(), -1);
        queue<int> q;
        level[s]=0;
        q.push(s);

        while(!q.empty()){
            int u=q.front(); q.pop();
            for(auto &e:G[u]){
                if(e.cap>0 && level[e.to]<0){
                    level[e.to]=level[u]+1;
                    q.push(e.to);
                }
            }
        }
        return level[t]>=0;
    }

    int dfs(int u,int t,int f){
        if(u==t) return f;
        for(int &i=it[u]; i<G[u].size(); i++){
            Edge &e=G[u][i];
            if(e.cap>0 && level[e.to]==level[u]+1){
                int got=dfs(e.to,t,min(f,e.cap));
                if(got){
                    e.cap-=got;
                    G[e.to][e.rev].cap += got;
                    return got;
                }
            }
        }
        return 0;
    }

    int maxflow(int s,int t){
        int flow=0;
        while(bfs(s,t)){
            fill(it.begin(),it.end(),0);
            while(int pushed = dfs(s,t,1e9))
                flow += pushed;
        }
        return flow;
    }
};

int main(){
    Dinic D(6);

    D.addEdge(0,1,30);
    D.addEdge(1,2,20);
    D.addEdge(0,3,25);
    D.addEdge(3,2,15);
    D.addEdge(2,5,40);

    cout<<"Max bike flow: "<<D.maxflow(0,5)<<"\n";
}
</pre>
</div>
<!-- ========================================================= -->
<!-- ================= CASE 8 ================================ -->
<!-- ========================================================= -->

<div id="c8" class="case-content">
<h2>8) Urban Tree Canopy Optimization</h2>

<p><b>Problem Statement:</b>  
Choose optimal plots for planting trees to reduce heat and increase carbon absorption while staying inside a limited city budget.</p>

<p><b>Algorithm Used:</b> Budgeted Submodular Maximization (Lazy Greedy)</p>

<p><b>Time Complexity:</b> O(n log n)</p>

<p><b>Conclusion:</b>  
This greedy approximation gives near-optimal green-cover benefit for a fixed planting budget.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Plot{
    int id;
    double cost, heat, carbon, shade;
    double score() const {
        return heat + carbon + shade;
    }
};

int main(){
    int n = 250;
    double B = 9000;
    double used = 0;

    vector<Plot> P(n);
    for(int i=0;i<n;i++){
        P[i] = {i,
                (rand()%120)+20,
                (rand()%200)/2.0,
                (rand()%150)/3.0,
                (rand()%180)/4.0};
    }

    vector<bool> chosen(n,false);
    priority_queue<pair<double,int>> pq;

    for(auto &p:P)
        pq.push({p.score()/p.cost, p.id});

    vector<int> selected;

    while(!pq.empty()){
        auto top = pq.top(); pq.pop();
        int id = top.second;
        if(chosen[id]) continue;

        if(used + P[id].cost <= B){
            chosen[id] = true;
            used += P[id].cost;
            selected.push_back(id);
        }
    }

    cout << "Selected: " << selected.size() << " plots\n";
    cout << "Budget used: " << used << "\n";
}
</pre>
</div>



<!-- ========================================================= -->
<!-- ================= CASE 9 ================================ -->
<!-- ========================================================= -->

<div id="c9" class="case-content">
<h2>9) Drone Corridor Planning With No-Fly Zones</h2>

<p><b>Problem Statement:</b>  
Compute safe airborne routes for delivery drones while avoiding government buildings, houses, hospitals, and restricted areas.</p>

<p><b>Algorithm Used:</b> A* Search on 8-direction Grid</p>

<p><b>Time Complexity:</b> O(E log V)</p>

<p><b>Conclusion:</b>  
A* gives shortest + safest corridor under dynamic obstacles and wind/noise penalties.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

int dx[8]={1,1,0,-1,-1,-1,0,1};
int dy[8]={0,1,1,1,0,-1,-1,-1};

double H(int x,int y,int tx,int ty){
    return hypot(tx-x, ty-y);
}

int main(){
    int W=200, Hh=200;
    vector<vector<int>> block(W, vector<int>(Hh,0));

    for(int i=60;i<90;i++)
        for(int j=70;j<110;j++)
            block[i][j] = 1;

    pair<int,int> s = {10,10}, t = {180,170};

    vector<vector<double>> g(W, vector<double>(Hh,1e18));
    vector<vector<pair<int,int>>> parent(W, vector<pair<int,int>>(Hh, {-1,-1}));

    priority_queue<
        pair<double,pair<int,int>>,
        vector<pair<double,pair<int,int>>>,
        greater<>
    > pq;

    g[s.first][s.second] = 0;
    pq.push({0,{s.first,s.second}});

    while(!pq.empty()){
        auto cur = pq.top(); pq.pop();
        int x = cur.second.first;
        int y = cur.second.second;

        if(x==t.first && y==t.second) break;

        for(int k=0;k<8;k++){
            int nx = x+dx[k];
            int ny = y+dy[k];

            if(nx<0||ny<0||nx>=W||ny>=Hh) continue;
            if(block[nx][ny]) continue;

            double move = hypot(dx[k], dy[k]);
            double noise = double(ny)/Hh;
            double nc = g[x][y] + move + noise*0.5;

            if(nc < g[nx][ny]){
                g[nx][ny] = nc;
                parent[nx][ny] = {x,y};
                double f = nc + H(nx,ny,t.first,t.second);
                pq.push({f,{nx,ny}});
            }
        }
    }

    vector<pair<int,int>> path;
    auto cur = t;
    while(cur != s && cur.first != -1){
        path.push_back(cur);
        cur = parent[cur.first][cur.second];
    }

    reverse(path.begin(), path.end());
    cout<<"Path length: "<<path.size()<<"\n";
}
</pre>
</div>



<!-- ========================================================= -->
<!-- ================= CASE 10 =============================== -->
<!-- ========================================================= -->

<div id="c10" class="case-content">
<h2>10) Affordable Housing Allocation</h2>

<p><b>Problem Statement:</b>  
City must assign limited government housing units to applicants based on priority (income, disability, family size, urgency).</p>

<p><b>Algorithm Used:</b> Gale–Shapley Stable Matching (Priority Version)</p>

<p><b>Time Complexity:</b> O(n × m)</p>

<p><b>Conclusion:</b>  
Ensures fair, conflict-free allocation respecting priority without bias.</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

int main(){
    int A=400, H=80;

    vector<vector<int>> pref(A);
    for(int i=0;i<A;i++)
        for(int j=0;j<10;j++)
            pref[i].push_back((i+j)%H);

    vector<int> cap(H,4);
    vector<int> next(A,0);
    vector<set<pair<int,int>>> house(H);

    vector<int> score(A);
    for(int i=0;i<A;i++) score[i] = rand()%100;

    queue<int> freeQ;
    for(int i=0;i<A;i++) freeQ.push(i);

    while(!freeQ.empty()){
        int a = freeQ.front(); freeQ.pop();
        if(next[a] >= pref[a].size()) continue;

        int h = pref[a][next[a]++];
        house[h].insert({-score[a], a});

        if(house[h].size() > cap[h]){
            auto worst = *prev(house[h].end());
            house[h].erase(worst);
            if(worst.second != a)
                freeQ.push(worst.second);
        }
    }

    int allocated = 0;
    for(int h=0;h<H;h++)
        allocated += house[h].size();

    cout<<"Allocated: "<<allocated<<"\n";
}
</pre>
</div>

