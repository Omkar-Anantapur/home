<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Abhilash – Case Studies</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
    margin:0;
    font-family:"Segoe UI",sans-serif;
    background:#020617;
    color:#e5e7eb;
}
h1{text-align:center;margin-top:30px;color:#e50914}
.case-buttons{
    max-width:900px;
    margin:30px auto;
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
    gap:20px;
}
.case-btn{
    padding:20px;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.25);
    border-radius:14px;
    text-align:center;
    cursor:pointer;
    transition:.3s;
}
.case-btn:hover{
    transform:translateY(-4px);
    border-color:#e50914;
    box-shadow:0 0 20px rgba(229,9,20,0.4);
}
.case-content{
    display:none;
    max-width:900px;
    margin:40px auto;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.2);
    padding:20px;
    border-radius:14px;
}
pre{
    background:black;
    padding:15px;
    border-radius:12px;
    overflow-x:auto;
    white-space:pre-wrap;
}
.back{
    display:inline-block;
    margin-top:20px;
    color:#38bdf8;
}
</style>

<script>
function openCase(n){
    document.querySelectorAll(".case-content").forEach(c=>c.style.display="none");
    document.getElementById("c"+n).style.display="block";
    window.scrollTo(0,0);
}
</script>
</head>

<body>

<h1>Abhilash – Case Studies (1–10)</h1>

<div class="case-buttons">
<script>
for(let i=1;i<=10;i++){
    document.write(`<div class='case-btn' onclick='openCase(${i})'>Business Case Study ${i}</div>`);
}
</script>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 1 ================================== -->
<!-- ========================================================= -->

<div id="c1" class="case-content">
<h2>1) Dynamic EV Charging Station Placement</h2>
<p><b>Problem:</b> Optimal placement of EV charging stations to minimize driver travel distance and balance loads.</p>
<p><b>Algorithm:</b> K-means + Greedy Load Assignment</p>
<p><b>Time Complexity:</b> O(I * n * k)</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

using P = pair<double,double>;
double dist(const P&a,const P&b){
    return hypot(a.first-b.first,a.second-b.second);
}

int main(){
    int n=1200, k=25, it=50;
    vector<P> points(n);

    mt19937 rng(1);
    uniform_real_distribution<double> U(0,200);
    for(int i=0;i<n;i++) points[i]={U(rng),U(rng)};

    vector<P> cent(k);
    for(int i=0;i<k;i++) cent[i]=points[i*(n/k)];

    vector<int> assign(n);

    for(int t=0;t<it;t++){
        vector<int> cnt(k,0);
        vector<P> sum(k,{0,0});

        for(int i=0;i<n;i++){
            int best=0; double bestd=1e18;
            for(int j=0;j<k;j++){
                double d=dist(points[i],cent[j]);
                if(d<bestd){bestd=d;best=j;}
            }
            assign[i]=best;
            cnt[best]++;
            sum[best].first+=points[i].first;
            sum[best].second+=points[i].second;
        }
        for(int j=0;j<k;j++){
            if(cnt[j]) cent[j]={sum[j].first/cnt[j],sum[j].second/cnt[j]};
        }
    }

    vector<int> cap(k,150);
    vector<vector<int>> served(k);

    for(int i=0;i<n;i++){
        int s=assign[i];
        if(served[s].size()<cap[s]) served[s].push_back(i);
        else{
            int best=-1; double bd=1e18;
            for(int j=0;j<k;j++){
                if(served[j].size()<cap[j]){
                    double d=dist(points[i],cent[j]);
                    if(d<bd){bd=d;best=j;}
                }
            }
            if(best!=-1) served[best].push_back(i);
        }
    }

    cout<<"Centers:\n";
    for(auto &c:cent) cout<<c.first<<" "<<c.second<<"\n";
}
</pre>
</div>


<!-- ========================================================= -->
<!-- =============== CASE 2 ================================== -->
<!-- ========================================================= -->

<div id="c2" class="case-content">
<h2>2) Public Health Outbreak Detection</h2>
<p><b>Algorithm:</b> DBSCAN + Temporal Window</p>
<p><b>Time Complexity:</b> O(n log n)</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct P{double x,y; int t;};
double dist(const P&a,const P&b){
    return hypot(a.x-b.x,a.y-b.y);
}

int main(){
    vector<P> pts;
    for(int i=0;i<600;i++)
        pts.push_back({rand()%150, rand()%150, rand()%48});

    int n=pts.size();
    double eps=1.2;
    int minpts=5;

    vector<int> vis(n,0), cid(n,-1);
    int C=0;

    for(int i=0;i<n;i++){
        if(vis[i]) continue;
        vis[i]=1;

        vector<int> nbr;
        for(int j=0;j<n;j++)
            if(dist(pts[i],pts[j])<=eps && abs(pts[i].t-pts[j].t)<=6)
                nbr.push_back(j);

        if(nbr.size()<minpts){cid[i]=-2; continue;}
        cid[i]=C;

        queue<int>q;
        for(int x:nbr) q.push(x);

        while(!q.empty()){
            int u=q.front(); q.pop();
            if(!vis[u]){
                vis[u]=1;
                vector<int> nbr2;
                for(int j=0;j<n;j++)
                    if(dist(pts[u],pts[j])<=eps && abs(pts[u].t-pts[j].t)<=6)
                        nbr2.push_back(j);
                if(nbr2.size()>=minpts)
                    for(int x:nbr2) if(!vis[x]) q.push(x);
            }
            if(cid[u]==-1) cid[u]=C;
        }
        C++;
    }

    cout<<"Clusters: "<<C<<"\n";
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 3 ================================== -->
<!-- ========================================================= -->

<div id="c3" class="case-content">
<h2>3) On-demand Microtransit Routing</h2>

<p><b>Algorithm:</b> Greedy VRP Insertion</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Req{int id; double x,y; int pax;};
struct Bus{int id; double x,y; int cap,load; vector<int> route;};

double dist(pair<double,double>a,pair<double,double>b){
    return hypot(a.first-b.first,a.second-b.second);
}

int main(){
    vector<Bus> bus;
    for(int i=0;i<10;i++)
        bus.push_back({i,rand()%120,rand()%120,15,0,{}});

    auto handle=[&](Req r){
        double best=1e18; int vid=-1;
        for(int i=0;i<bus.size();i++){
            if(bus[i].load+r.pax > bus[i].cap) continue;
            double d = dist({bus[i].x,bus[i].y},{r.x,r.y});
            if(d<best){best=d;vid=i;}
        }
        if(vid==-1){cout<<"Rejected\n";return;}
        bus[vid].route.push_back(r.id);
        bus[vid].load+=r.pax;
        cout<<"Assigned "<<r.id<<" to "<<vid<<"\n";
    };

    for(int i=0;i<50;i++)
        handle({i,rand()%120,rand()%120,1});

    return 0;
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 4 ================================== -->
<!-- ========================================================= -->

<div id="c4" class="case-content">
<h2>4) Waste Collection Optimization</h2>

<p><b>Algorithm:</b> Clarke–Wright Savings</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Node{int id; double x,y; int demand;};
double dist(Node&a,Node&b){return hypot(a.x-b.x,a.y-b.y);}

int main(){
    Node depot={0,50,50,0};
    int n=25;
    vector<Node> N;
    for(int i=1;i<=n;i++)
        N.push_back({i,rand()%100,rand()%100,rand()%20+10});

    int cap=260;
    struct R{vector<int> seq; int load;};

    map<int,R> routes;
    for(auto &x:N) routes[x.id]={{x.id},x.demand};

    vector<tuple<double,int,int>> S;
    for(int i=0;i<n;i++)for(int j=i+1;j<n;j++){
        double s=dist(depot,N[i])+dist(depot,N[j])-dist(N[i],N[j]);
        S.push_back({s,N[i].id,N[j].id});
    }
    sort(S.begin(),S.end(),greater<>());

    for(auto&t:S){
        double s; int a,b; tie(s,a,b)=t;
        int ra=-1,rb=-1;
        for(auto &r:routes){
            auto &seq=r.second.seq;
            if(seq.front()==a || seq.back()==a) ra=r.first;
            if(seq.front()==b || seq.back()==b) rb=r.first;
        }
        if(ra<0||rb<0||ra==rb) continue;

        if(routes[ra].load + routes[rb].load <= cap){
            auto merged=routes[ra].seq;
            merged.insert(merged.end(),routes[rb].seq.begin(),routes[rb].seq.end());
            routes[ra].seq=merged;
            routes[ra].load+=routes[rb].load;
            routes.erase(rb);
        }
    }
    cout<<"Routes: "<<routes.size()<<"\n";
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 5 ================================== -->
<!-- ========================================================= -->

<div id="c5" class="case-content">
<h2>5) Smart Streetlight Energy Allocation</h2>

<p><b>Algorithm:</b> Greedy by safety-per-energy</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Slot{int id,energy; double safety;};

int main(){
    int n=120,b=1500;
    vector<Slot> S;
    for(int i=0;i<n;i++)
        S.push_back({i,rand()%20+5,(rand()%100)/100.0});

    sort(S.begin(),S.end(),
        [](auto&a,auto&b){
            return (a.safety/a.energy) > (b.safety/b.energy);
        }
    );

    int used=0;
    vector<int> ON;

    for(auto&s:S){
        if(used+s.energy <= b){
            used+=s.energy;
            ON.push_back(s.id);
        }
    }
    cout<<"Lights ON: "<<ON.size()<<"\n";
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 6 ================================== -->
<!-- ========================================================= -->

<div id="c6" class="case-content">
<h2>6) Micro-Fulfillment Center Placement</h2>

<p><b>Algorithm:</b> Greedy Facility Opening</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

using P=pair<double,double>;
double dist(const P&a,const P&b){
    return hypot(a.first-b.first,a.second-b.second);
}

int main(){
    int n=500,cand=50,K=12;
    vector<P>d(n),cl(cand);

    for(int i=0;i<n;i++) d[i]={rand()%200,rand()%200};
    for(int i=0;i<cand;i++) cl[i]={rand()%200,rand()%200};

    vector<int> open,assign(n,-1);

    for(int k=0;k<K;k++){
        double best=-1; int bestC=-1;
        for(int c=0;c<cand;c++){
            if(find(open.begin(),open.end(),c)!=open.end()) continue;
            double gain=0;
            for(int i=0;i<n;i++){
                double cur=(assign[i]==-1?1e9:dist(d[i],cl[assign[i]]));
                double nd=dist(d[i],cl[c]);
                if(nd<cur) gain+=(cur-nd);
            }
            if(gain>best){best=gain;bestC=c;}
        }
        if(bestC==-1) break;
        open.push_back(bestC);

        for(int i=0;i<n;i++){
            double bd=1e18; int bi=-1;
            for(int o:open){
                double dd=dist(d[i],cl[o]);
                if(dd<bd){bd=dd;bi=o;}
            }
            assign[i]=bi;
        }
    }
    cout<<"Centers opened: "<<open.size()<<"\n";
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 7 ================================== -->
<!-- ========================================================= -->

<div id="c7" class="case-content">
<h2>7) Adaptive Bicycle Lane Reallocation</h2>

<p><b>Algorithm:</b> Dinic Max Flow</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Edge{int to,rev,cap;};
struct Dinic{
    int N;
    vector<vector<Edge>>G;
    vector<int>L,it;
    Dinic(int n):N(n),G(n),L(n),it(n){}

    void addEdge(int u,int v,int c){
        G[u].push_back({v,(int)G[v].size(),c});
        G[v].push_back({u,(int)G[u].size()-1,0});
    }

    bool bfs(int s,int t){
        fill(L.begin(),L.end(),-1);
        queue<int>q; L[s]=0; q.push(s);
        while(!q.empty()){
            int u=q.front();q.pop();
            for(auto&e:G[u])
                if(e.cap>0 && L[e.to]==-1){
                    L[e.to]=L[u]+1;
                    q.push(e.to);
                }
        }
        return L[t]!=-1;
    }

    int dfs(int u,int t,int f){
        if(u==t) return f;
        for(int&i=it[u];i<G[u].size();i++){
            Edge&e=G[u][i];
            if(e.cap>0 && L[e.to]==L[u]+1){
                int r=dfs(e.to,t,min(f,e.cap));
                if(r){
                    e.cap-=r; G[e.to][e.rev].cap+=r;
                    return r;
                }
            }
        }
        return 0;
    }

    int maxflow(int s,int t){
        int flow=0;
        while(bfs(s,t)){
            fill(it.begin(),it.end(),0);
            while(int f=dfs(s,t,1e9)) flow+=f;
        }
        return flow;
    }
};

int main(){
    Dinic D(6);
    D.addEdge(0,1,30);
    D.addEdge(1,2,20);
    D.addEdge(0,3,25);
    D.addEdge(3,2,15);
    D.addEdge(2,5,40);
    cout<<"Max flow: "<<D.maxflow(0,5)<<"\n";
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 8 ================================== -->
<!-- ========================================================= -->

<div id="c8" class="case-content">
<h2>8) Urban Tree Canopy Optimization</h2>

<p><b>Algorithm:</b> Submodular Greedy Approximation</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

struct Plot{
    int id; double cost; double b1,b2,b3;
    double score(){return b1+b2+b3;}
};

int main(){
    int n=250; double B=9000,used=0;
    vector<Plot>P;
    for(int i=0;i<n;i++)
        P.push_back({i,(rand()%120)+20,
            (rand()%200)/2.0,(rand()%150)/2.0,(rand()%100)/1.5
        });

    vector<bool>sel(n,false);
    priority_queue<pair<double,int>>pq;

    for(auto&p:P)
        pq.push({p.score()/p.cost,p.id});

    vector<int>ans;

    while(!pq.empty()){
        auto top=pq.top(); pq.pop();
        int id=top.second;
        if(sel[id]) continue;
        if(used + P[id].cost <= B){
            sel[id]=true;
            used+=P[id].cost;
            ans.push_back(id);
        }
    }
    cout<<"Selected "<<ans.size()<<" plots\n";
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 9 ================================== -->
<!-- ========================================================= -->

<div id="c9" class="case-content">
<h2>9) Drone Corridor Planning</h2>

<p><b>Algorithm:</b> A* Search on Grid</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

int dx[8]={1,1,0,-1,-1,-1,0,1};
int dy[8]={0,1,1,1,0,-1,-1,-1};

double H(int x,int y,int tx,int ty){
    return hypot(tx-x,ty-y);
}

int main(){
    int W=200,Hh=200;
    vector<vector<int>>block(W,vector<int>(Hh,0));

    for(int i=60;i<90;i++)
        for(int j=70;j<110;j++)
            block[i][j]=1;

    pair<int,int>s={10,10},t={190,170};
    vector<vector<double>>g(W,vector<double>(Hh,1e18));
    vector<vector<pair<int,int>>>par(W,vector<pair<int,int>>(Hh,{-1,-1}));

    priority_queue<
        pair<double,pair<int,int>>,
        vector<pair<double,pair<int,int>>>,
        greater<>
    >pq;

    g[s.first][s.second]=0;
    pq.push({0,{s.first,s.second}});

    while(!pq.empty()){
        auto cur=pq.top(); pq.pop();
        int x=cur.second.first, y=cur.second.second;
        if(x==t.first && y==t.second) break;

        for(int k=0;k<8;k++){
            int nx=x+dx[k], ny=y+dy[k];
            if(nx<0||ny<0||nx>=W||ny>=Hh) continue;
            if(block[nx][ny]) continue;

            double move = hypot(dx[k],dy[k]);
            double noise = double(ny)/Hh;

            double nc=g[x][y]+move+noise;

            if(nc < g[nx][ny]){
                g[nx][ny]=nc;
                par[nx][ny]={x,y};
                double f = nc + H(nx,ny,t.first,t.second);
                pq.push({f,{nx,ny}});
            }
        }
    }

    vector<pair<int,int>>path;
    auto cur=t;
    while(cur!=s && cur.first!=-1){
        path.push_back(cur);
        cur=par[cur.first][cur.second];
    }
    reverse(path.begin(),path.end());

    cout<<"Path length: "<<path.size()<<"\n";
}
</pre>
</div>

<!-- ========================================================= -->
<!-- =============== CASE 10 ================================== -->
<!-- ========================================================= -->

<div id="c10" class="case-content">
<h2>10) Affordable Housing Allocation</h2>

<p><b>Algorithm:</b> Gale–Shapley Matching with Priority</p>

<pre>
#include <bits/stdc++.h>
using namespace std;

int main(){
    int A=400,H=90;
    vector<vector<int>> pref(A);
    for(int i=0;i<A;i++)
        for(int j=0;j<10;j++)
            pref[i].push_back((i+j)%H);

    vector<int>cap(H,4);
    vector<int>next(A,0);
    vector<set<pair<int,int>>>house(H);

    vector<int>score(A);
    for(int i=0;i<A;i++) score[i]=rand()%100;

    queue<int>freeQ;
    for(int i=0;i<A;i++) freeQ.push(i);

    while(!freeQ.empty()){
        int a=freeQ.front(); freeQ.pop();
        if(next[a]>=pref[a].size()) continue;

        int h=pref[a][next[a]++];
        house[h].insert({-score[a],a});

        if(house[h].size()>cap[h]){
            auto worst=*prev(house[h].end());
            house[h].erase(worst);
            int out=worst.second;
            if(out!=a) freeQ.push(out);
        }
    }

    int alloc=0;
    for(int h=0;h<H;h++)
        alloc+=house[h].size();

    cout<<"Allocated: "<<alloc<<"\n";
}
</pre>
</div>

</body>
</html>
