<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Business Case Study 7 – Crime Hotspot Detection Using 2D Prefix Sums</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  background:#0f172a;
  color:#e5e7eb;
  font-family:"Segoe UI",sans-serif;
  margin:0;
  padding:2rem;
  line-height:1.7;
}
a { color:#38bdf8; text-decoration:none; }
a:hover { text-decoration:underline; }
.container {
  max-width:1100px; margin:auto;
  background:#020617; padding:2rem;
  border-radius:12px; border:1px solid #1e293b;
}
h1 { color:#e50914; text-align:center; margin-bottom:1.5rem; letter-spacing:2px; }
h2 { margin-top:2rem; color:#f97316; }
h3 { margin-top:1.2rem; color:#a5b4fc; }
.section {
  margin-top:2rem; padding:1.5rem;
  background:#0b1120; border-radius:10px;
  border:1px solid #1e293b;
}
pre {
  background:#111827; padding:1rem; border-radius:8px;
  overflow-x:auto; border:1px solid #1e293b; font-size:0.9rem;
}
</style>
</head>

<body>

<a href="bheemangouda.html">← Back</a>

<div class="container">

<h1>Business Case Study 7 – Crime Hotspot Detection in City Grid</h1>

<div class="section">
<h2>1. Problem Statement</h2>

<p>
Cities like Hubballi-Dharwad divide the entire city into a **2D grid** of zones.  
Each grid cell stores the **number of crimes reported** in that particular area in the last month.
</p>

<p>
Police need to answer queries like:
</p>

<ul>
<li>Total crimes in a rectangular area</li>
<li>Hotspot detection by scanning various blocks</li>
<li>Find regions that exceed threshold values</li>
<li>Query hundreds of times per second</li>
</ul>

<p>
A brute force scan for each query is slow:
</p>

<pre>O(n*m) per query → too slow for real city data</pre>

<p>
2D Prefix Sum solves this efficiently.
</p>

</div>

<div class="section">
<h2>2. Algorithm Used: 2D Prefix Sum</h2>

<p>
Prefix sum precomputes a matrix where each cell contains the sum of all values in the rectangle from (0,0) to (i,j).
</p>

<p>
Querying a rectangle (x1,y1) to (x2,y2) becomes:
</p>

<pre>
sum = pref[x2][y2] 
      - pref[x1-1][y2] 
      - pref[x2][y1-1] 
      + pref[x1-1][y1-1]
</pre>

<p>This reduces query time to:</p>

<pre>O(1) per query</pre>

</div>

<div class="section">
<h2>3. Time Complexity Explanation</h2>

<pre>
Building prefix matrix: O(n*m)
Each query: O(1)
Total performance: extremely fast for large data
</pre>

<p>
This is ideal for real-time dashboards in police control rooms.
</p>

</div>

<div class="section">
<h2>4. C++ Code (Very Long Version – with utilities, printing, validation, helpers)</h2>

<pre><code>
#include <bits/stdc++.h>
using namespace std;

class CrimeGrid {
public:
    int n, m;
    vector<vector<int>> grid;
    vector<vector<int>> pref;

    CrimeGrid(int rows, int cols) {
        n = rows;
        m = cols;
        grid.assign(n, vector<int>(m, 0));
        pref.assign(n + 1, vector<int>(m + 1, 0));
    }

    void randomFill(int maxVal = 5) {
        srand(time(NULL));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                grid[i][j] = rand() % maxVal;
            }
        }
    }

    void manualFill(vector<vector<int>> data) {
        if ((int)data.size() != n || (int)data[0].size() != m) {
            cout << "Error: Input size mismatch.\n";
            return;
        }
        grid = data;
    }

    void buildPrefix() {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                pref[i][j] = grid[i-1][j-1] 
                    + pref[i-1][j]
                    + pref[i][j-1]
                    - pref[i-1][j-1];
            }
        }
    }

    int query(int x1, int y1, int x2, int y2) {
        if (x1 < 0 || y1 < 0 || x2 >= n || y2 >= m || x1 > x2 || y1 > y2) {
            cout << "Invalid query.\n";
            return -1;
        }

        int X1 = x1 + 1;
        int Y1 = y1 + 1;
        int X2 = x2 + 1;
        int Y2 = y2 + 1;

        int sum = pref[X2][Y2]
                - pref[X1-1][Y2]
                - pref[X2][Y1-1]
                + pref[X1-1][Y1-1];

        return sum;
    }

    void printGrid() {
        cout << "\n===== CRIME GRID =====\n";
        for (auto &row : grid) {
            for (int v : row) cout << v << " ";
            cout << "\n";
        }
        cout << "=======================\n";
    }

    void printPrefix() {
        cout << "\n===== PREFIX MATRIX =====\n";
        for (auto &row : pref) {
            for (int v : row) cout << v << " ";
            cout << "\n";
        }
        cout << "=========================\n";
    }

    void hotspotScan(int threshold) {
        cout << "\n===== HOTSPOT SCAN (T > " << threshold << ") =====\n";
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] > threshold) {
                    cout << "Hotspot at (" << i << "," << j 
                         << ") with " << grid[i][j] << " incidents\n";
                }
            }
        }
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n = 5, m = 5;
    CrimeGrid cg(n, m);

    cg.randomFill(10);
    cg.buildPrefix();

    cg.printGrid();
    cg.printPrefix();

    cout << "\nQuery: Total crimes in rectangle (1,1) to (3,3)\n";
    cout << cg.query(1, 1, 3, 3) << " reported\n";

    cg.hotspotScan(7);

    cout << "\nSystem simulation completed.\n";
    return 0;
}
</code></pre>

</div>

<div class="section">
<h2>5. Conclusion</h2>

<p>
This 2D prefix-sum approach is the backbone of crime analytics dashboards.  
It scales effortlessly and supports thousands of fast queries, helping police identify crime clusters instantly.
</p>

</div>

</div>

</body>
</html>
